The way I decided to sort out a feeding schedule for each quokkas was to understand its eating habits. I assumed that the number of selfies per day (S) was dependent on the amount of food consumed (fc) that same day. This allows the ability to create a mathematical function using Lagrange polynomial interpolation. So a Lagrange polynomial is generated by using the data that already exists, specifically the non-zero ordered pairs (fc, S). Thus each individual animals eating habit is represented by a mathematical model. This model can be used to make future feeding predictions. More on that in a bit.

For the following note that: fp - food prepared, df = fp - fc
Concerning the constraints: Maximize - S/fc; and Minimize - df. I decided to create a ratio: (S/fc)/df = (S/(fc-df)) = (S/(fc(fp-fc))) = tr (tr - target ratio, used as a variable during calculations). The idea for this was to streamline the constraints into one calculation. If we maximize this ratio we satisfy the constraints.

How does my code work? Here are some key points:
(1) It reads in animal.txt
(2) It stores the largest value for tr ( max(tr) ) of any animal.
(3) Lagrange polynomial interpolation is performed for each animal.
(4) It calculates the present day feeding amount based on previous days fc and fp. (I designed this program to be used by the quokkas organization when rationing out food for the day).

So because of the Lagrange polynomial interpolation a function (mathematical model) is generated. Sorted out by id#: What goes into the function is yesterdays fc, what comes out (of the polynomial) is a predicted amount of selfies for the day. These predicted number of selfies, yesterdays fc, and yesterdays fp are then used to create a temporary ratio (calculated in the same way tr is above) which is then judged against max(tr). Added into the code is a level of accuracy. So a level of 95 would show if yesterdays fc was within 5% or max(tr). At the end of the source code you shall find 'if' statements with inequalities in them which shall shed some light on these ideas I've just mentioned.

I adopted a strategy to use each animal id# with each data point by multiplying them. Before any output is given the user is asked for an id#. So for id = 3 with a corresponding fc = 7 the data stored would be 21, or id*fc, or 3*7. Thus each data point stored is a multiple of that animal id#. To extract each value, fc/id is performed. This how i categorized all data used in each calculation per id#. The way this code works basically highlights the best performing animal, max(tr), and makes all the other animal try to match that.